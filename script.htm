<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
<script>

  //no zeros for heros
function noBoringZeros(n) {
  if(n === 0){
    return n
  }
  let result;
  for(let i = n; i % 1 === 0; i /= 10){
  result = i;
  }
  return result;
}

// Welcome!
function greet(language) {
  const greeting = {
    english: 'Welcome',
    czech: 'Vitejte',
    danish: 'Velkomst',
    dutch: 'Welkom',
    estonian: 'Tere tulemast',
    finnish: 'Tervetuloa',
    flemish: 'Welgekomen',
    french: 'Bienvenue',
    german: 'Willkommen',
    irish: 'Failte',
    italian: 'Benvenuto',
    latvian: 'Gaidits',
    lithuanian: 'Laukiamas',
    polish: 'Witamy',
    spanish: 'Bienvenido',
    swedish: 'Valkommen',
    welsh: 'Croeso'
  }

  return greeting[language] ?? greeting.english;
}

// Simple multiplication: This kata is about multiplying a given number by eight if it is an even number and by nine otherwise.

function simpleMultiplication(number) {
  return (number % 2 === 0) ? number * 8 : number * 9
}

// Capitalization and Mutability

function capitalizeWord(word) {
  word = word[0].toUpperCase() + word.slice(1);
  return word;
}

// Who ate the cookie?
// For this problem you must create a program that says who ate the last cookie. If the input is a string then "Zach" ate the cookie. If the input is a float or an int then "Monica" ate the cookie. If the input is anything else "the dog" ate the cookie. The way to return the statement is: "Who ate the last cookie? It was (name)!"
// Ex: Input = "hi" --> Output = "Who ate the last cookie? It was Zach! (The reason you return Zach is because the input is a string)
// Note: Make sure you return the correct message with correct spaces and punctuation.
// Please leave feedback for this kata. Cheers!

function cookie(x){
  let name;

  switch (typeof x) {
    case 'string':
      name = 'Zach';
    break;
    case 'number':
      name = 'Monica';
    break;
    default:
      name = 'the dog';
    break;
  }

  return 'Who ate the last cookie? It was '+ name + '!'
}

// Who is going to pay for the wall?
// Don Drumphet lives in a nice neighborhood, but one of his neighbors has started to let his house go. Don Drumphet wants to build a wall between his house and his neighbor’s, and is trying to get the neighborhood association to pay for it. He begins to solicit his neighbors to petition to get the association to build the wall. Unfortunately for Don Drumphet, he cannot read very well, has a very limited attention span, and can only remember two letters from each of his neighbors’ names. As he collects signatures, he insists that his neighbors keep truncating their names until two letters remain, and he can finally read them.
// Your code will show Full name of the neighbor and the truncated version of the name as an array. If the number of the characters in name is less than or equal to two, it will return an array containing only the name as is"

function whoIsPaying(name){
  if(name.length <= 2) return [name];

  const truncated = name.slice(0, 2);

  return [name, truncated]
}

// Write a function which calculates the average of the numbers in a given list.
// Note: Empty arrays should return 0.

function findAverage(array) {
  if(array.length === 0) {
    return 0
  }
  const sum = array.reduce((previousValue, item) =>
    previousValue + item);
  return sum / array.length;
}

//Write a function which takes a number and returns the corresponding ASCII char for that value.
function getChar(c){
  return String.fromCharCode(c)
}

// Given a number n, draw stairs using the letter "I", n tall and n wide, with the tallest in the top left.
function drawStairs(n) {
  const stair = `I`;
  let stairs = stair;
  const space = ' ';
  const anotherStair = '\n';

  for(let i = 1; i < n; i++){
    stairs += anotherStair + space.repeat(i) + stair;
  }

  return stairs
}

//Define a function that removes duplicates from an array of non negative numbers and returns it as a result.
//The order of the sequence has to stay the same.

function distinct(a) {
  const result = a.reduce((prevVal, item)=> {
    if (!prevVal.find(d => d === item)){
      prevVal.push(item)
    }
    return prevVal
  }, [])

  return result
}

//The purpose of this kata is to work out just how many bottles of duty free whiskey you would have to buy such that the savings over the normal high street price would effectively cover the cost of your holiday.
//You will be given the high street price (normPrice, in £ (Pounds)), the duty free discount (discount, in percent) and the cost of the holiday (in £).
//For example, if a bottle costs £10 normally and the duty free discount is 10%, you would save £1 per bottle. If your holiday will cost £500, you would have to purchase 500 bottles to save £500, so the answer you return should be 500.
//Another example: if a bottle costs £12 normally and the duty free discount is 50%, you would save £6 per bottle. If your holiday will cost £1000, you would have to purchase 166.66 bottles to save £1000, so your answer should be 166 bottles.
//All inputs will be integers. Please return an integer. Round down.

function dutyFree(normPrice, discount, hol){
  const savings = (normPrice * discount) / 100;
  const items = Math.floor(hol / savings)
  return items
}

// In this exercise, you will have to create a function named tiyFizzBuzz. This function will take on a string parameter and will return that string with some characters replaced, depending on the value:

// If a letter is a upper case consonants, replace that character with "Iron".
// If a letter is a lower case consonants or a non-alpha character, do nothing to that character
// If a letter is a upper case vowel, replace that character with "Iron Yard".
// If a letter is a lower case vowel, replace that character with "Yard".

function tiyFizzBuzz(sentence){
  let string = '';
  sentence.split('').forEach(letter => {
    if(/[^a-zAIUEO\s\W\d]/.test(letter)){
      string += 'Iron'
    } else if(/[AIUEO]/.test(letter)){
      string += 'Iron Yard'
    } else if(/[aiueo]/.test(letter)){
      string += 'Yard'
    } else {
      string += letter
    }
  })

  return string
}

// Your task is simply to count the total number of lowercase letters in a string.
function lowercaseCount(str){
  let counter = 0;
  str.split('').forEach(letter =>{
    if(/[a-z]/.test(letter)) counter++
  })
  return counter
}

// refactor lowercaseCount
function lowercaseCount(str){
    return (str.match(/[a-z]/g) ?? []).length
}

function properName(noun){
  let nameCapitalized = '';
  noun.split(' ').forEach(name =>{
    nameCapitalized += name[0].toUpperCase() + name.slice(1) + ' '
  })
  return nameCapitalized.trim()
}

// Convert Decimal Degrees to Degrees, Minutes, Seconds.
// Remember: 1 degree = 60 minutes; 1 minute = 60 seconds.
// Input: Positive number.
// Output: Array [degrees, minutes, seconds]. E.g [30, 25, 25]
//Trailing zeroes should be omitted in the output. E.g

function convert(degrees) {
  let min = (degrees - Math.floor(degrees)) * 60;
  let sec = (min - Math.floor(min)) * 60;
  degrees = Math.floor(degrees);
  min = Math.floor(min);
  sec = Math.round(sec);

  if(sec){
    return [degrees, min, sec]
  } else if(min){
    return [degrees, min]
  } else {
    return [degrees]
  }
}



function triangular(n) {
  if(n <= 0) return 0;
  return Array(n)
          .fill(1)
          .map((num, i) => num + i)
          .reduce((prevVal, item) =>prevVal + item)
}

// You will be given an array of events, which are represented by strings. The strings are dates in HH:MM:SS format.
// It is known that all events are recorded in chronological order and two events can't occur in the same second.
// Return the minimum number of days during which the log is written.

function checkLogs(log) {
  let days = 1;
  log.reduce((prevTime, time)=> {
    if(prevTime >= time) days++
    return time
  }, 0)
  return log.length !== 0
    ? days
    : 0
}

// const checkLogs = log => log.reduce((d, t, i, arr) => i ? d + (t <= arr[i - 1]) : d, 1)

// Converting a 12-hour time like "8:30 am" or "8:30 pm" to 24-hour time (like "0830" or "2030") sounds easy enough, right? Well, let's see if you can do it!
// You will have to define a function, which will be given an hour (always in the range of 1 to 12, inclusive), a minute (always in the range of 0 to 59, inclusive), and a period (either "am" or "pm") as input.
// Your task is to return a four-digit string that encodes that time in 24-hour time.

function to24hourtime(hour, minute, period) {
  switch (period) {
    case 'am':
      if(hour === 12) hour = '00'
      break
    case 'pm':
      if(hour !== 12) hour += 12
  }

  return hour.toString().padStart(2, '0') + ':' + minute.toString().padStart(2, '0')
}

// Write a function that takes a string of parentheses,
// and determines if the order of the parentheses is valid. The function should return true if the string is valid, and false if it's invalid.
function validParentheses(parenStr) {
  while (parenStr.includes("()")) {
    parenStr = parenStr.replace("()","");
  }
  return parenStr.length === 0;
}

// You are given two numbers a and b where 0 ≤ a ≤ b. Imagine you construct an array of all the integers from a to b inclusive.
// You need to count the number of 1s in the binary representations of all the numbers in the array.

/* function rangeBitCount(a, b) {
  const array = []
  while(b >= a) {
    const binary = Number(b).toString(2)
    array.push(
      binary
        .replace(/0+/g, '')
        .split('')
        .length
      )
      b--
    }

  return array.reduce((prevNum, num)=> prevNum + num)
} */

function rangeBitCount(a, b) {
  let sum = 0

  while(b >= a) {
    sum += (b--)
      .toString(2)
      .replace(/0+/g, '')
      .split('')
      .length
  }

  return sum
}

// An infinite number of shelves are arranged one above the other in a staggered fashion.

function solution(start, finish) {
  const track = finish - start

  return Math.floor(track / 3) + track % 3
}

// Complete the solution so that it returns the number of times the search_text is found within the full_text.

function countMatches(fullText, searchText) {
  return (fullText.match(RegExp(searchText, 'g')) ?? []).length
}

function distinctNames(list) {
  return list.filter((name, index, array)=>
    array.findIndex(item=> item.toLowerCase() === name.toLowerCase()) === index
  )
}

/* The Situation
In my bathroom, there is a pile of n towels. A towel either has the color red or blue.
We will represent the pile as sequence of red and blue.The leftmost towel is at the bottom of the pile,
the rightmost towel is at the top of the pile.

As the week goes by, I use t towels. Whenever I grab a new one it's always the towel at the top of the pile.
All used towels are placed in a basket.

At the end of the week, I wash all used towels in the basket and put them on top of the existing pile again.
But my favorite color is blue, so I want to use blue towels as often as possible. Therefore,
when the washed towels are placed on the pile again, the blue towels are always on top of the red towels.

An Example
If there are n=5 towels, a pile may be:blue, red, blue, red, blue

If I grab t=3 towels during the week, this will be the remaining pile at the end of the week: blue, red

The basket will contain the following towels: blue, red, blue

After I sorted the washed towels and put them on the pile according to the rule described above,
the resulting pile is:blue, red, red, blue, blue

Your Task: Sort the Pile
You are given an initial pile of towels as a sequence of the strings "red" and "blue".
On top of that, you receive a sequence of non-negative integers.
The first integer describes the number of used towels t in the first week,
the second integer describes the number of used towels t in the second week and so forth.

My question is: How will my pile of towels look like in the end,
if I use t towels every week and place them on top of the the pile according to the rule defined above?

Notes
It is ensured that 0 <= t <= n */

const pileOfTowels = ["blue", "red", "blue", "red", "blue"]

function sortThePile(pileOfTowels, weeklyUsedTowels) {
  weeklyUsedTowels.forEach(use=> {
    const dirt = pileOfTowels.splice(-use, use)
    const cleaned = dirt.sort().reverse()
    pileOfTowels.push(...cleaned)
  })
  return pileOfTowels;
}

// Create a function that checks if the first argument n is divisible by all other arguments
// (return true if no other arguments)

function isDivisible(){
  return Array(...arguments)
    .every((num, i, arr)=> arr.at(0) % num === 0)
}

</script>
</body>
</html>