<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
<script>

  //no zeros for heros
function noBoringZeros(n) {
  if(n === 0){
    return n
  }
  let result;
  for(let i = n; i % 1 === 0; i /= 10){
  result = i;
  }
  return result;
}

// Welcome!
function greet(language) {
  const greeting = {
    english: 'Welcome',
    czech: 'Vitejte',
    danish: 'Velkomst',
    dutch: 'Welkom',
    estonian: 'Tere tulemast',
    finnish: 'Tervetuloa',
    flemish: 'Welgekomen',
    french: 'Bienvenue',
    german: 'Willkommen',
    irish: 'Failte',
    italian: 'Benvenuto',
    latvian: 'Gaidits',
    lithuanian: 'Laukiamas',
    polish: 'Witamy',
    spanish: 'Bienvenido',
    swedish: 'Valkommen',
    welsh: 'Croeso'
  }

  return greeting[language] ?? greeting.english;
}

// Simple multiplication: This kata is about multiplying a given number by eight if it is an even number and by nine otherwise.

function simpleMultiplication(number) {
  return (number % 2 === 0) ? number * 8 : number * 9
}

// Capitalization and Mutability

function capitalizeWord(word) {
  word = word[0].toUpperCase() + word.slice(1);
  return word;
}

// Who ate the cookie?
// For this problem you must create a program that says who ate the last cookie. If the input is a string then "Zach" ate the cookie. If the input is a float or an int then "Monica" ate the cookie. If the input is anything else "the dog" ate the cookie. The way to return the statement is: "Who ate the last cookie? It was (name)!"
// Ex: Input = "hi" --> Output = "Who ate the last cookie? It was Zach! (The reason you return Zach is because the input is a string)
// Note: Make sure you return the correct message with correct spaces and punctuation.
// Please leave feedback for this kata. Cheers!

function cookie(x){
  let name;

  switch (typeof x) {
    case 'string':
      name = 'Zach';
    break;
    case 'number':
      name = 'Monica';
    break;
    default:
      name = 'the dog';
    break;
  }

  return 'Who ate the last cookie? It was '+ name + '!'
}

// Who is going to pay for the wall?
// Don Drumphet lives in a nice neighborhood, but one of his neighbors has started to let his house go. Don Drumphet wants to build a wall between his house and his neighbor’s, and is trying to get the neighborhood association to pay for it. He begins to solicit his neighbors to petition to get the association to build the wall. Unfortunately for Don Drumphet, he cannot read very well, has a very limited attention span, and can only remember two letters from each of his neighbors’ names. As he collects signatures, he insists that his neighbors keep truncating their names until two letters remain, and he can finally read them.
// Your code will show Full name of the neighbor and the truncated version of the name as an array. If the number of the characters in name is less than or equal to two, it will return an array containing only the name as is"

function whoIsPaying(name){
  if(name.length <= 2) return [name];

  const truncated = name.slice(0, 2);

  return [name, truncated]
}

// Write a function which calculates the average of the numbers in a given list.
// Note: Empty arrays should return 0.

function findAverage(array) {
  if(array.length === 0) {
    return 0
  }
  const sum = array.reduce((previousValue, item) =>
    previousValue + item);
  return sum / array.length;
}

//Write a function which takes a number and returns the corresponding ASCII char for that value.
function getChar(c){
  return String.fromCharCode(c)
}

// Given a number n, draw stairs using the letter "I", n tall and n wide, with the tallest in the top left.
function drawStairs(n) {
  const stair = `I`;
  let stairs = stair;
  const space = ' ';
  const anotherStair = '\n';

  for(let i = 1; i < n; i++){
    stairs += anotherStair + space.repeat(i) + stair;
  }

  return stairs
}

//Define a function that removes duplicates from an array of non negative numbers and returns it as a result.
//The order of the sequence has to stay the same.

function distinct(a) {
  const result = a.reduce((prevVal, item)=> {
    if (!prevVal.find(d => d === item)){
      prevVal.push(item)
    }
    return prevVal
  }, [])

  return result
}

//The purpose of this kata is to work out just how many bottles of duty free whiskey you would have to buy such that the savings over the normal high street price would effectively cover the cost of your holiday.
//You will be given the high street price (normPrice, in £ (Pounds)), the duty free discount (discount, in percent) and the cost of the holiday (in £).
//For example, if a bottle costs £10 normally and the duty free discount is 10%, you would save £1 per bottle. If your holiday will cost £500, you would have to purchase 500 bottles to save £500, so the answer you return should be 500.
//Another example: if a bottle costs £12 normally and the duty free discount is 50%, you would save £6 per bottle. If your holiday will cost £1000, you would have to purchase 166.66 bottles to save £1000, so your answer should be 166 bottles.
//All inputs will be integers. Please return an integer. Round down.

function dutyFree(normPrice, discount, hol){
  const savings = (normPrice * discount) / 100;
  const items = Math.floor(hol / savings)
  return items
}

// In this exercise, you will have to create a function named tiyFizzBuzz. This function will take on a string parameter and will return that string with some characters replaced, depending on the value:

// If a letter is a upper case consonants, replace that character with "Iron".
// If a letter is a lower case consonants or a non-alpha character, do nothing to that character
// If a letter is a upper case vowel, replace that character with "Iron Yard".
// If a letter is a lower case vowel, replace that character with "Yard".

function tiyFizzBuzz(sentence){
  let string = '';
  sentence.split('').forEach(letter => {
    if(/[^a-zAIUEO\s\W\d]/.test(letter)){
      string += 'Iron'
    } else if(/[AIUEO]/.test(letter)){
      string += 'Iron Yard'
    } else if(/[aiueo]/.test(letter)){
      string += 'Yard'
    } else {
      string += letter
    }
  })

  return string
}

// Your task is simply to count the total number of lowercase letters in a string.
function lowercaseCount(str){
  let counter = 0;
  str.split('').forEach(letter =>{
    if(/[a-z]/.test(letter)) counter++
  })
  return counter
}

// refactor lowercaseCount
function lowercaseCount(str){
    return (str.match(/[a-z]/g) ?? []).length
}

/* function properName(noun){
  let nameCapitalized = '';
  noun.split(' ').forEach(name =>{
    nameCapitalized += name[0].toUpperCase() + name.slice(1) + ' '
  })
  return nameCapitalized.trim()
} */

function properName(noun) {
  return noun.replace(/(^|\s)[a-z]/g, c=> c.toUpperCase())
}

// Convert Decimal Degrees to Degrees, Minutes, Seconds.
// Remember: 1 degree = 60 minutes; 1 minute = 60 seconds.
// Input: Positive number.
// Output: Array [degrees, minutes, seconds]. E.g [30, 25, 25]
//Trailing zeroes should be omitted in the output. E.g

function convert(degrees) {
  let min = (degrees - Math.floor(degrees)) * 60;
  let sec = (min - Math.floor(min)) * 60;
  degrees = Math.floor(degrees);
  min = Math.floor(min);
  sec = Math.round(sec);

  if(sec){
    return [degrees, min, sec]
  } else if(min){
    return [degrees, min]
  } else {
    return [degrees]
  }
}



function triangular(n) {
  if(n <= 0) return 0;
  return Array(n)
          .fill(1)
          .map((num, i) => num + i)
          .reduce((prevVal, item) =>prevVal + item)
}

// You will be given an array of events, which are represented by strings. The strings are dates in HH:MM:SS format.
// It is known that all events are recorded in chronological order and two events can't occur in the same second.
// Return the minimum number of days during which the log is written.

function checkLogs(log) {
  let days = 1;
  log.reduce((prevTime, time)=> {
    if(prevTime >= time) days++
    return time
  }, 0)
  return log.length !== 0
    ? days
    : 0
}

// const checkLogs = log => log.reduce((d, t, i, arr) => i ? d + (t <= arr[i - 1]) : d, 1)

// Converting a 12-hour time like "8:30 am" or "8:30 pm" to 24-hour time (like "0830" or "2030") sounds easy enough, right? Well, let's see if you can do it!
// You will have to define a function, which will be given an hour (always in the range of 1 to 12, inclusive), a minute (always in the range of 0 to 59, inclusive), and a period (either "am" or "pm") as input.
// Your task is to return a four-digit string that encodes that time in 24-hour time.

function to24hourtime(hour, minute, period) {
  switch (period) {
    case 'am':
      if(hour === 12) hour = '00'
      break
    case 'pm':
      if(hour !== 12) hour += 12
  }

  return hour.toString().padStart(2, '0') + ':' + minute.toString().padStart(2, '0')
}

// Write a function that takes a string of parentheses,
// and determines if the order of the parentheses is valid. The function should return true if the string is valid, and false if it's invalid.
function validParentheses(parenStr) {
  while (parenStr.includes("()")) {
    parenStr = parenStr.replace("()","");
  }
  return parenStr.length === 0;
}

// You are given two numbers a and b where 0 ≤ a ≤ b. Imagine you construct an array of all the integers from a to b inclusive.
// You need to count the number of 1s in the binary representations of all the numbers in the array.

/* function rangeBitCount(a, b) {
  const array = []
  while(b >= a) {
    const binary = Number(b).toString(2)
    array.push(
      binary
        .replace(/0+/g, '')
        .split('')
        .length
      )
      b--
    }

  return array.reduce((prevNum, num)=> prevNum + num)
} */

function rangeBitCount(a, b) {
  let sum = 0

  while(b >= a) {
    sum += (b--)
      .toString(2)
      .replace(/0+/g, '')
      .split('')
      .length
  }

  return sum
}

// An infinite number of shelves are arranged one above the other in a staggered fashion.

function solution(start, finish) {
  const track = finish - start

  return Math.floor(track / 3) + track % 3
}

// Complete the solution so that it returns the number of times the search_text is found within the full_text.

function countMatches(fullText, searchText) {
  return (fullText.match(RegExp(searchText, 'g')) ?? []).length
}

function distinctNames(list) {
  return list.filter((name, index, array)=>
    array.findIndex(item=> item.toLowerCase() === name.toLowerCase()) === index
  )
}

/* The Situation
In my bathroom, there is a pile of n towels. A towel either has the color red or blue.
We will represent the pile as sequence of red and blue.The leftmost towel is at the bottom of the pile,
the rightmost towel is at the top of the pile.

As the week goes by, I use t towels. Whenever I grab a new one it's always the towel at the top of the pile.
All used towels are placed in a basket.

At the end of the week, I wash all used towels in the basket and put them on top of the existing pile again.
But my favorite color is blue, so I want to use blue towels as often as possible. Therefore,
when the washed towels are placed on the pile again, the blue towels are always on top of the red towels.

An Example
If there are n=5 towels, a pile may be:blue, red, blue, red, blue

If I grab t=3 towels during the week, this will be the remaining pile at the end of the week: blue, red

The basket will contain the following towels: blue, red, blue

After I sorted the washed towels and put them on the pile according to the rule described above,
the resulting pile is:blue, red, red, blue, blue

Your Task: Sort the Pile
You are given an initial pile of towels as a sequence of the strings "red" and "blue".
On top of that, you receive a sequence of non-negative integers.
The first integer describes the number of used towels t in the first week,
the second integer describes the number of used towels t in the second week and so forth.

My question is: How will my pile of towels look like in the end,
if I use t towels every week and place them on top of the the pile according to the rule defined above?

Notes
It is ensured that 0 <= t <= n */

const pileOfTowels = ["blue", "red", "blue", "red", "blue"]

function sortThePile(pileOfTowels, weeklyUsedTowels) {
  weeklyUsedTowels.forEach(use=> {
    const dirt = pileOfTowels.splice(-use, use)
    const cleaned = dirt.sort().reverse()
    pileOfTowels.push(...cleaned)
  })
  return pileOfTowels;
}

// Create a function that checks if the first argument n is divisible by all other arguments
// (return true if no other arguments)

function isDivisible(){
  return Array(...arguments)
    .every((num, i, arr)=> arr.at(0) % num === 0)
}

/* Reverse a message so that the words and letters passed into it are made lower case and reversed.
In addition, capitalise the first letter of the newly reversed words.
If a number or symbol(!#,>) is now in the first position of the word, no capitalisation needs to occur. */

/* function reverseMessage(str) {
  if(!Boolean(str)) return ''
  const lowerCase = str.toLowerCase(),
  invert = lowerCase.split('').reverse().join(''),
  capitalize = invert
    .split(' ')
    .map(word=> word[0].toUpperCase() + word.slice(1)),
  sentence = capitalize.join(' ')

  return sentence
} */

/* const reverseMessage = str=> {
  str
    .toLowerCase()
    .split('')
    .reverse()
    .join('')
    .split(' ')
    .map(word=> word[0].toUpperCase() + word.slice(1))
    .join(' ')
} */

const reverseMessage = str=>
  str
    .toLowerCase()
    .split('')
    .reverse()
    .join('')
    .replace(/(^|\s)[a-z]/g, c=> c.toUpperCase())

// Capitalize for each word within a string

function capitalize(str) {
  return str
    .split(' ')
    .map(word=> word.at(0).toUpperCase() + word.slice(1))
    .join(' ')
}

// Kevin is noticing his space run out!
// Write a function that removes the spaces from the values
// and returns an array showing the space decreasing.

function spacey(array) {
  return array.map((str, idx, arr)=>
    arr.slice(0, idx).join('').concat(str)
  )
}

const arr = [1, 2, 3, 4, 5, 6]

const circleArea = function(radius) {
  if(isNaN(radius) || radius < 0) return false

  const area = Math.PI * (radius ** 2)

  return +area.toFixed(2)
}

// Create a function that takes a string argument
// and returns that same string with all vowels removed (vowels are "a", "e", "i", "o", "u").

const removeVowels = function(str){
  return str.replace(/[aiueo]/g, '')
}

/* Given some points(array A) on the same line,
determine the minimum number of line segments with length L needed to cover all of the given points.
A point is covered if it is located inside some segment or on its bounds.
 */

/* function segmentCover(A, L) {
  let segments = 0

  A.sort((a, b)=> a - b)

  for(let i = 0; i !== -1;) {
    const newIndex = A.findIndex(elem=>
      elem > A.at(i) + L
    )

    i = (segments++, newIndex)
  }

  return segments
} */

function segmentCover(A, L) {
  console.log(1 + A.filter(x => x > Math.min(...A) + L))
  return A.length === 0
    ? 0
    : 1 + segmentCover(A.filter(x => x > Math.min(...A) + L), L)
}

function lisa() {
  for(var i = 0; i < 3; i++) {
    setTimeout(console.log, 100, i)
  }
}

// The function is not returning the correct values. Can you figure out why?
// done!
// this is a Inmidiatly invoked object expression

function getPlanetName(id){
  return {
    1: 'Mercury',
    2: 'Venus',
    3: 'Earth',
    4: 'Mars',
    5: 'Jupiter',
    6: 'Saturn',
    7: 'Uranus',
    8: 'Neptune'
  }[id]
}

/* const pets = [
  {nombre: 'pelusa', edad: 12, tipo:'gato'},
  {nombre:'puchini', edad:12, tipo:'perro'},
  {nombre:'pulga', edad:10, tipo:'perro'},
  {nombre:'chanchito', edad:3, tipo:'perro'}
]

const idx = pets.reduce((value, item)=> ({
  [item.nombre]: item, ...value
}))

console.log(idx) */


// This kata is part of a series on the Morse code. After you solve this kata, you may move to the next one.

const decodeMorse = function(morseCode){
  return morseCode
    .trim()
    .replace(/\S+/g, letter=> MORSE_CODE[letter])
    .replace(/\s+/g, match=>
      match.length === 1
        ? ''
        : ' '
    )
}


/* const url = 'http://www.example.com/page.html';
const domain = url.match(/^(?:https?:\/\/)?(?:www\.)?([^:\/\n]+)/i);
console.log(domain); */

/* /^(?:https?:\/\/)?(?:www\.)?([^:\/\n]+)/i
/^(?:https?:\/\/)?(?:www\.)?([^:\/\n.]+)/i */


// Write a function that when given a URL as a string,
// parses out just the domain name and returns it as a string. For example:

function domainName(url){
  return url.match(/^(?:https?:\/\/)?(?:www\.)?([^:.]+)/i)[1];
}

function parseTitle(metastring) {
  return metastring.match(/title=(["'])(.*?)\1/)[2];
}

/* console.log(
parseTitle('title="foo"'), // 'foo'
parseTitle("title='foo' lang='en'"), // 'foo'
parseTitle('title="Named capturing groups\' advantages"') // "Named capturing groups' advantages"
)

console.log(/(ab)|(cd)/d.exec("cd").indices.at(2).at(1)) */


/* There are pillars near the road. The distance between the pillars is the same
and the width of the pillars is the same. Your function accepts three arguments:

number of pillars (≥ 1);
distance between pillars (10 - 30 meters);
width of the pillar (10 - 50 centimeters).
Calculate the distance between the first and the last pillar in centimeters
(without the width of the first and last pillar). */



function pillars(numPill, dist, width) {
  const
    lonelyPill = numPill < 2,
    middlePills = numPill - 2 + lonelyPill,
    distOnCm = dist * 100,
    distantPill = numPill - 1

  return distOnCm * distantPill + width * middlePills
}

// Your task is to find the first element of an array that is not consecutive.

function firstNonConsecutive (arr) {
  let prevVal = arr.at(0)

  for(const num of arr) {
    if(prevVal - num !== 0) return num
    else prevVal = num + 1
  }

  return null
}


const order = ["manzana", "banana", "naranja", "banana", "manzana", "banana"];

const result = order.reduce(function (prevVal, item) {
  !prevVal[item]
    ? prevVal[item] = 1
    : prevVal[item]++

  return prevVal;
}, {})

// When transmitting the Morse code, the international standard specifies that:

// "Dot" – is 1 time unit long.
// "Dash" – is 3 time units long.
// Pause between dots and dashes in a character – is 1 time unit long.
// Pause between characters inside a word – is 3 time units long.
// Pause between words – is 7 time units long.
// However, the standard does not specify how long that "time unit" is.
// And in fact different operators would transmit at different speed.
// An amateur person may need a few seconds to transmit a single character,
// a skilled professional can transmit 60 words per minute, and robotic transmitters may go way faster.

const decodeBits = function(bits){
  const
    test = /^0|0$/.test(bits),
    rates = test
      ? bits
          .replace(/^0|0$/g, '')
          .match(/(1+|0+)/g)
          .map(rate=> rate.length)
      : bits
          .match(/(1+|0+)/g)
          .map(rate=> rate.length),
    minRate = Math.min(...rates);

  return bits
    .replace(/(1+)|0+/g, ({length}, signal)=> {
      if(signal) {
          if(length === minRate) return '.'
          else return '-'
      } else {
          if(length === minRate) return ''
          else if(length === minRate * 3) return ' '
          else return '   '
      }
    })
} // need to use decodeMorse

function biggest(nums) {
  function maxNum(a, b) {
    const
      first = ''.concat(a, b),
      second = ''.concat(b, a)

    return first < second
      ? 1
      : -1
  }

  return nums
    .sort(maxNum)
    .join('')
    .replace(/^0+/, '0')
}

// Write a function that reverses the bits in an integer.
// For example, the number 417 is 110100001 in binary. Reversing the binary is 100001011 which is 267.
// You can assume that the number is not negative.

function reverseBits (n) {
  return parseInt(n.toString(2).split('').reverse().join(''), 2)
}


// Please write a function that sums a list, but ignores any duplicate items in the list.
// For instance, for the list [3, 4, 3, 6] , the function should return 10.

function sumNoDuplicates(numList) {
  return numList
    .reduce((acc, num, _, list)=>{
      const repeated = list.indexOf(num) !== list.lastIndexOf(num);

      return repeated
        ? acc
        : acc + num
    }, 0)
}


</script>
</body>
</html>